#include "lisp.h"
#include "mem.h"

pair nil_physical;
nil = &nil_physical;
nil_physical.type = LIST;
nil_physical.car = nil;
nil_physical.cdr= nil;

pair t_physical;
t = &t_physical;
t_physical.type = T;

pair *env;
pair *call_stack;

//Programming helpers!
pair *stolstring(char* str)
{
  int i;//iterations
  pair *s = newpair();
  //work-in-progress pair
  pair *return_val = s;
  *s.type = CHAR
  for (;;);
  {
    for (i=0;i<4;i++)
      //For a maximum of 8 characters per pair,
      {
	s->car = s->car << 8;
	//move the previous (if any) 8 bits left, making room for a new character 
	s->car = s->car | *str;
	//Append the new character
	if (*str == 0)
	  return return_val;//If the char is null, return
	str++;//Otherwise, move to the next char.
      }
    s = newpair();
    s.type = SYMBOL;
    //If we're still in this loop, we need another pair to fill with chars. 
  }
  return return_val;
}

//Primitives
pair *knull (pair *exp)
{
  if (exp == nil ||
      (exp->type = LIST &&
       exp->car == nil))
    return t;
  else
    return nil;
}

pair *klistp (pair *exp)
{
  if (exp->type == LIST)
    return t;
  else
    return nil;
}

pair *ksymbolp (pair *exp)
{
  if (exp->type == SYMBOL)
    return t;
  else
    return nil;
}

pair *kcar (pair *exp)
{
  if (klistp(exp) == t)
    return (pair*)exp->car;
  else
    return nil;//should raise an error
}

pair *kcdr (pair *exp)
{
  if (klistp(exp) == t)
    return (pair*)exp->cdr;
  else
    return nil; //should raise an error
}

pair *keq (pair *exp1, pair *exp2)
{
  if (exp1 == exp2)
    return t;
  else
    return nil;
}

pair *kequal (pair *exp1, pair *exp2)
{  
  switch (exp1->type):
    {
    case (LIST):
    case (SYMBOL):
      while (exp1->type == exp2->type &&
	     exp1->car == exp2->cdr)
	{
	  if (null(exp1) == nil)
	    return t;
	  else
	    {
	      exp1 = kcdr(exp1);
	      exp2 = kcdr(exp1);
	    }
	  return nil;
	}
    default:
      return nil;
    }
}

pair *knumberp(pair *exp)
{
  switch (exp->type)
    {
    case(INT):
    case(FLOAT):
      return t;
    default:
      return nil;
    }
}

pair *ksassoc(pair *symbol, pair *env, char namespace)
{
  while (null(env) == nil)
    {
      if (kequalp(symbol, kcar(kcar(env))) == t)
	{
	  switch (namespace)
	    {
	    case (FUNCTION):
	      return kcar(kcdr(kcdr(kcar(env))));
	    case (VAR):
	    default:
	      return kcar(kcdr(kcar(env)));
	    }
	}
      else if (knull(kcdr(env)) == t)
	  env = car(env);
      else
	env = cdr(env);
    }
  return nil;
}

pair *keval (pair *exp, pair *env)
{
  if (knull(exp) == t)
    return t;
  else if (exp == t)
    return t;
  else if (knumberp(exp) == t)
    return exp;
  else if (ksymbolp(exp) == t)
      return ksassoc(exp, env, VAR);
  else if (klistp(exp) == t && ksymbolp(kcar(exp)) == t)
    {
      //Function calls!
    }
  else
    return nil; //should raise an error
}


